/**
 * API Client Interface for Todo Management Application
 * 
 * This is an interface-only definition with flattened input/output types.
 * All types are defined inline (no dependencies).
 * 
 * Input parameters are flattened: params, query, and body are combined into a single object.
 * Output types are flattened: response wrappers are unwrapped (e.g., Todo instead of { data: Todo }).
 */

// ============================================================================
// Enums
// ============================================================================

/**
 * Priority levels in ascending order of importance
 * @example "low" | "medium" | "high" | "urgent"
 */
type Priority = "low" | "medium" | "high" | "urgent";

/**
 * Status values as stored in the database
 * Note: "due" is never stored, only calculated on-demand
 * @example "initial" | "complete"
 */
type StoredStatus = "initial" | "complete";

/**
 * Status values as returned to clients (includes calculated "due")
 * @example "initial" | "complete" | "due"
 */
type CalculatedStatus = "initial" | "complete" | "due";

// ============================================================================
// Core Todo Model
// ============================================================================

/**
 * Todo object as returned by the API
 * 
 * @property id - Unique identifier (UUID v4)
 * @property title - Todo title (1-100 characters)
 * @property description - Optional detailed description (max 1000 characters, nullable)
 * @property status - Calculated status (can be "due" if overdue)
 * @property dueDate - Optional due date in YYYY-MM-DD format (nullable)
 * @property priority - Priority level
 * @property createdAt - Creation timestamp in ISO 8601 format (e.g., "2025-11-10T10:00:00.000Z")
 * @property modifiedAt - Last modification timestamp in ISO 8601 format
 */
type Todo = {
  id: string; // UUID v4
  title: string; // min: 1, max: 100 characters
  description: string | null; // max: 1000 characters, nullable
  status: CalculatedStatus; // "initial" | "complete" | "due"
  dueDate: string | null; // YYYY-MM-DD format, nullable
  priority: Priority; // "low" | "medium" | "high" | "urgent"
  createdAt: string; // ISO 8601 timestamp with millisecond precision
  modifiedAt: string; // ISO 8601 timestamp with millisecond precision
};

// ============================================================================
// Request Types (Flattened)
// ============================================================================

/**
 * Create Todo Request (flattened)
 * 
 * **Required Fields**: Only title is required. All other fields are optional.
 * 
 * **Default Values**: If priority is not provided, it defaults to "medium". The status is
 * automatically set to "initial" and cannot be specified during creation. Timestamps
 * (createdAt, modifiedAt) are automatically generated.
 * 
 * **Date Validation**: The dueDate cannot be set to a date in the past. Date format must be
 * YYYY-MM-DD. If not provided, the todo will have no due date.
 * 
 * **Auto-Generated Fields**: The id (UUID v4), createdAt, and modifiedAt are automatically
 * generated by the server and returned in the response.
 * 
 * @property title - Required, 1-100 characters, non-whitespace - The todo title
 * @property description - Optional, max 1000 characters - Detailed description of the todo
 * @property dueDate - Optional, YYYY-MM-DD format, cannot be in the past - Due date for the todo
 * @property priority - Optional, defaults to "medium" - Priority level ("low" | "medium" | "high" | "urgent")
 * 
 * @example Minimal todo - only title required
 * {
 *   title: "Buy groceries"
 * }
 * 
 * @example Complete todo with all fields
 * {
 *   title: "Complete project documentation",
 *   description: "Write comprehensive API documentation",
 *   dueDate: "2025-12-31",
 *   priority: "high"
 * }
 * 
 * @example Todo with due date and default priority
 * {
 *   title: "Review Q4 budget",
 *   dueDate: "2025-11-23"
 * }
 */
type CreateTodoRequest = {
  title: string; // min: 1, max: 100 characters
  description?: string | undefined; // max: 1000 characters
  dueDate?: string | undefined; // YYYY-MM-DD format, cannot be past
  priority?: Priority | undefined; // defaults to "medium"
};

/**
 * Update Todo Request (flattened with id)
 * 
 * **Partial Update**: All fields are optional except id. This allows updating only specific
 * fields without affecting others. At least one field (besides id) must be provided for update.
 * 
 * **Status Updates**: The status field accepts "initial" or "complete" only. The "due" status
 * is calculated automatically and cannot be set directly. Status transitions are validated
 * (e.g., cannot transition from "complete" back to "initial").
 * 
 * **Date Validation**: The dueDate cannot be set to a date in the past. Pass null to clear
 * an existing dueDate. Date format must be YYYY-MM-DD.
 * 
 * **Clearing Fields**: Pass null for description or dueDate to clear those fields. Other fields
 * cannot be cleared (they must have a value if provided).
 * 
 * @property id - Required, UUID v4 - The unique identifier of the todo to update
 * @property title - Optional, 1-100 characters - New title for the todo
 * @property description - Optional, max 1000 characters, or null to clear - New description or null to remove
 * @property dueDate - Optional, YYYY-MM-DD format, or null to clear, cannot be in the past - New due date or null to remove
 * @property status - Optional, "initial" or "complete" (cannot be "due") - New status (validated for transitions)
 * @property priority - Optional - New priority level
 * 
 * @example Partial update - change status and priority only
 * {
 *   id: "550e8400-e29b-41d4-a716-446655440000",
 *   status: "complete",
 *   priority: "urgent"
 * }
 * 
 * @example Update multiple fields
 * {
 *   id: "550e8400-e29b-41d4-a716-446655440000",
 *   title: "Updated title",
 *   description: "Updated description",
 *   dueDate: "2025-12-31"
 * }
 * 
 * @example Clear description and update dueDate
 * {
 *   id: "550e8400-e29b-41d4-a716-446655440000",
 *   description: null,
 *   dueDate: "2025-12-31"
 * }
 */
type UpdateTodoRequest = {
  id: string; // UUID v4, required
  title?: string | undefined; // min: 1, max: 100 characters
  description?: string | null | undefined; // max: 1000 characters, nullable
  dueDate?: string | null | undefined; // YYYY-MM-DD format, nullable, cannot be past
  status?: StoredStatus | undefined; // "initial" | "complete" (cannot be "due")
  priority?: Priority | undefined;
};

/**
 * List Todos Query Parameters (flattened)
 * 
 * Filter format: fieldname=comparator:value (for status, priority, title, description)
 *                or direct value (for dueDateBefore, dueDateAfter)
 * Only one filter per field is allowed (except dueDateBefore and dueDateAfter can be used together).
 * 
 * **IMPORTANT - Filter Combination**: Multiple different fields can be combined with AND logic.
 * You can combine any combination of status, priority, title, description, dueDateBefore, and
 * dueDateAfter filters in a single query. All filters must match (AND logic). This allows for
 * powerful server-side filtering without needing client-side post-processing.
 * 
 * **Date Filtering**: The `dueDateBefore` and `dueDateAfter` filters accept absolute dates in
 * YYYY-MM-DD format. For relative date filtering (e.g., "30 days ago", "end of this week"),
 * calculate the absolute date client-side and pass it to these filters. Both filters can be
 * used together to create date ranges.
 * 
 * **Status Filtering**: The "due" status is calculated on-demand and can be filtered using
 * `status: "equals:due"` or `status: "notEquals:due"`. This is useful for finding overdue todos.
 * 
 * **Text Filtering**: The `title` and `description` filters use case-insensitive substring matching.
 * Use "contains:text" to find todos containing text, or "notContains:text" to exclude todos.
 * 
 * @property status - Optional, format: "equals:initial" | "equals:complete" | "equals:due" | "notEquals:initial" | "notEquals:complete" | "notEquals:due"
 *                   Filters by calculated status. "due" is calculated on-demand for todos with
 *                   a dueDate that is in the past and status is "initial".
 * 
 * @property priority - Optional, format: "equals:low" | "equals:medium" | "equals:high" | "equals:urgent" | "notEquals:low" | "notEquals:medium" | "notEquals:high" | "notEquals:urgent"
 *                      Filters by priority level. Use "equals" for exact match or "notEquals" to exclude.
 * 
 * @property dueDateBefore - Optional, format: "YYYY-MM-DD" (filters todos with due date before this date, exclusive)
 *                           Must be a valid date in YYYY-MM-DD format. Can be combined with dueDateAfter
 *                           to create date ranges. Use with status: "equals:due" to find overdue todos
 *                           older than a specific date.
 * 
 * @property dueDateAfter - Optional, format: "YYYY-MM-DD" (filters todos with due date after this date, exclusive)
 *                          Must be a valid date in YYYY-MM-DD format. Can be combined with dueDateBefore
 *                          to create date ranges (e.g., todos due this week).
 * 
 * @property title - Optional, format: "contains:text" | "notContains:text" (case-insensitive)
 *                   Filters by substring match in title. Case-insensitive matching. Use "contains"
 *                   to find todos with text, or "notContains" to exclude todos with text.
 * 
 * @property description - Optional, format: "contains:text" | "notContains:text" (case-insensitive)
 *                         Filters by substring match in description. Case-insensitive matching.
 *                         Use "contains" to find todos with text, or "notContains" to exclude.
 * 
 * @example Basic filtering - single field
 * {
 *   status: "equals:initial"
 * }
 * 
 * @example Multiple field combination - status, priority, and title
 * {
 *   status: "equals:initial",
 *   priority: "notEquals:low",
 *   title: "contains:meeting"
 * }
 * 
 * @example Date range filtering - todos due in a specific period
 * {
 *   dueDateBefore: "2025-12-31",
 *   dueDateAfter: "2025-01-01",
 *   status: "notEquals:complete"
 * }
 * 
 * @example Overdue todos - combining status "due" with date filter
 * // Find todos that are overdue and due date is before a specific cutoff date
 * {
 *   status: "equals:due",
 *   dueDateBefore: "2025-01-01"  // Todos overdue before this date
 * }
 * 
 * @example Excluding items - combining multiple exclusion filters
 * // Get incomplete todos due this week, excluding urgent items
 * {
 *   status: "notEquals:complete",
 *   dueDateAfter: "2025-11-10",
 *   dueDateBefore: "2025-11-16",
 *   title: "notContains:urgent",      // Exclude todos with "urgent" in title
 *   priority: "notEquals:urgent"      // Exclude todos with urgent priority
 * }
 * 
 * @example Complex combination - all filter types together
 * {
 *   status: "equals:initial",
 *   priority: "notEquals:low",
 *   title: "notContains:meeting",
 *   description: "notContains:urgent",
 *   dueDateAfter: "2025-11-01",
 *   dueDateBefore: "2025-11-30"
 * }
 */
type ListTodosQuery = {
  status?: string | undefined; // "equals:initial" | "equals:complete" | "equals:due" | "notEquals:initial" | "notEquals:complete" | "notEquals:due"
  priority?: string | undefined; // "equals:low" | "equals:medium" | "equals:high" | "equals:urgent" | "notEquals:low" | "notEquals:medium" | "notEquals:high" | "notEquals:urgent"
  dueDateBefore?: string | undefined; // "YYYY-MM-DD" format
  dueDateAfter?: string | undefined; // "YYYY-MM-DD" format
  title?: string | undefined; // "contains:text" | "notContains:text" (case-insensitive)
  description?: string | undefined; // "contains:text" | "notContains:text" (case-insensitive)
};

/**
 * Get Todo by ID Request (flattened)
 * 
 * @property id - Required, UUID v4
 * 
 * @example
 * {
 *   id: "550e8400-e29b-41d4-a716-446655440000"
 * }
 */
type GetTodoByIdRequest = {
  id: string; // UUID v4, required
};

/**
 * Delete Todo Request (flattened)
 * 
 * @property id - Required, UUID v4
 * 
 * @example
 * {
 *   id: "550e8400-e29b-41d4-a716-446655440000"
 * }
 */
type DeleteTodoRequest = {
  id: string; // UUID v4, required
};

/**
 * Bulk Update Status Request (flattened)
 * 
 * @property ids - Required, array of UUIDs, min: 1, max: 100 items
 * @property status - Required, "initial" or "complete"
 * 
 * @example
 * {
 *   ids: ["550e8400-e29b-41d4-a716-446655440000", "660e8400-e29b-41d4-a716-446655440001"],
 *   status: "complete"
 * }
 */
type BulkUpdateStatusRequest = {
  ids: string[]; // min: 1, max: 100 UUIDs
  status: StoredStatus; // "initial" | "complete"
};

/**
 * Bulk Delete Request (flattened)
 * 
 * @property ids - Required, array of UUIDs, min: 1, max: 100 items
 * 
 * @example
 * {
 *   ids: ["550e8400-e29b-41d4-a716-446655440000", "660e8400-e29b-41d4-a716-446655440001"]
 * }
 */
type BulkDeleteRequest = {
  ids: string[]; // min: 1, max: 100 UUIDs
};

// ============================================================================
// API Client Interface
// ============================================================================

/**
 * API Client Interface for Todo Management
 * 
 * All methods use flattened input/output types:
 * - Input: params, query, and body are combined into a single flat object
 * - Output: response wrappers are unwrapped (e.g., Todo instead of { data: Todo })
 * - Methods could be tagged with the following @tags: ["mutating", "readonly", "filterable", "batch", "search", "create", "read", "list", "update", "delete", "sortable", "patch", "idempotent", "async", "paginated", "async-status-check", "compensating", "rate-limited", "not-rate-limited", "cached"]
 */
interface IApiClient {
  /**
   * Creates a new todo
   * 
   * Corresponds to: POST /api/v1/todos
   * 
   * @param request - Create todo request (flattened)
   * @returns Todo object with generated id, createdAt, modifiedAt, and status set to "initial"
   * @throws Error with message if validation fails (400) or server error (500)
   * 
   * @example
   * const todo = await client.createTodo({
   *   title: "Complete project documentation",
   *   description: "Write comprehensive API documentation",
   *   dueDate: "2025-12-31",
   *   priority: "high"
   * });
   * 
   * @tags: ["mutating", "create"]
   */
  createTodo(request: CreateTodoRequest): Promise<Todo>;

  /**
   * Lists todos with optional filtering
   * 
   * Corresponds to: GET /api/v1/todos
   * 
   * All filtering is performed server-side. Multiple filters can be combined with AND logic.
   * This method returns todos with calculated status (including "due" for overdue todos).
   * 
   * @param request - List todos query parameters (flattened, all optional)
   * @returns Array of todo objects with calculated status
   * @throws Error with message if filter validation fails (400) or server error (500)
   * 
   * @example Get all todos
   * const allTodos = await client.listTodos({});
   * 
   * @example Basic filtering - single field
   * const todos = await client.listTodos({
   *   status: "equals:initial"
   * });
   * 
   * @example Multiple field combination
   * const todos = await client.listTodos({
   *   status: "equals:initial",
   *   priority: "notEquals:low",
   *   title: "contains:meeting"
   * });
   * 
   * @example Find overdue todos older than a specific date
   * // Calculate cutoffDate (30 days ago) client-side, then filter server-side
   * const overdueTodos = await client.listTodos({
   *   status: "equals:due",
   *   dueDateBefore: cutoffDate  // e.g., "2025-10-11"
   * });
   * 
   * @example Find incomplete todos due this week, excluding urgent
   * const todos = await client.listTodos({
   *   status: "notEquals:complete",
   *   dueDateAfter: weekStart,      // e.g., "2025-11-10"
   *   dueDateBefore: weekEnd,       // e.g., "2025-11-16"
   *   title: "notContains:urgent",
   *   priority: "notEquals:urgent"
   * });
   * 
   * @tags: ["readonly", "filterable", "list", "search"]
   */
  listTodos(request?: ListTodosQuery): Promise<Todo[]>;

  /**
   * Gets a todo by ID
   * 
   * Corresponds to: GET /api/v1/todos/:id
   * 
   * @param request - Get todo request with id (flattened)
   * @returns Todo object with calculated status
   * @throws Error with message if todo not found (404) or server error (500)
   * 
   * @example
   * const todo = await client.getTodoById({
   *   id: "550e8400-e29b-41d4-a716-446655440000"
   * });
   * 
   * @tags: ["readonly", "read"]
   */
  getTodoById(request: GetTodoByIdRequest): Promise<Todo>;

  /**
   * Updates a todo (partial update)
   * 
   * Corresponds to: PATCH /api/v1/todos/:id
   * 
   * @param request - Update todo request with id and optional fields (flattened)
   * @returns Updated todo object with calculated status
   * @throws Error with message if validation fails (400), todo not found (404), invalid status transition (400), or server error (500)
   * 
   * @example
   * const updated = await client.updateTodo({
   *   id: "550e8400-e29b-41d4-a716-446655440000",
   *   title: "Updated title",
   *   status: "complete",
   *   priority: "urgent"
   * });
   * 
   * @tags: ["mutating", "update", "patch"]
   */
  updateTodo(request: UpdateTodoRequest): Promise<Todo>;

  /**
   * Deletes a todo
   * 
   * Corresponds to: DELETE /api/v1/todos/:id
   * 
   * @param request - Delete todo request with id (flattened)
   * @returns void (204 No Content)
   * @throws Error with message if todo not found (404) or server error (500)
   * 
   * @example
   * await client.deleteTodo({
   *   id: "550e8400-e29b-41d4-a716-446655440000"
   * });
   * 
   * @tags: ["mutating", "delete"]
   */
  deleteTodo(request: DeleteTodoRequest): Promise<void>;

  /**
   * Bulk update status for multiple todos
   * 
   * Corresponds to: POST /api/v1/todos/bulk-update-status
   * 
   * **IMPORTANT - Batch Limit**: This method accepts a maximum of 100 todo IDs per call.
   * If you have more than 100 todos to update, process them in batches of 100.
   * 
   * **Atomic Operation**: The operation is atomic - all todos succeed or all fail (rollback on any error).
   * This ensures data consistency. If any todo in the batch cannot be updated (e.g., not found,
   * invalid status transition), the entire operation fails and no todos are updated.
   * 
   * @param request - Bulk update status request (flattened)
   * @returns Array of updated todo objects with calculated status
   * @throws Error with message if validation fails (400), any todo not found (404), invalid transition (400), exceeds max limit (400), or server error (500)
   * 
   * @example Basic bulk update
   * const updated = await client.bulkUpdateStatus({
   *   ids: ["550e8400-e29b-41d4-a716-446655440000", "660e8400-e29b-41d4-a716-446655440001"],
   *   status: "complete"
   * });
   * 
   * @example Batch processing for large sets (>100 todos)
   * const allTodoIds = [...]; // Array of more than 100 IDs
   * const batchSize = 100;
   * for (let i = 0; i < allTodoIds.length; i += batchSize) {
   *   const batch = allTodoIds.slice(i, i + batchSize);
   *   await client.bulkUpdateStatus({ ids: batch, status: "complete" });
   * }
   * 
   * @tags: ["mutating", "batch", "update", "patch"]
   */
  bulkUpdateStatus(request: BulkUpdateStatusRequest): Promise<Todo[]>;

  /**
   * Bulk delete multiple todos
   * 
   * Corresponds to: POST /api/v1/todos/bulk-delete
   * 
   * **IMPORTANT - Batch Limit**: This method accepts a maximum of 100 todo IDs per call.
   * If you have more than 100 todos to delete, process them in batches of 100.
   * 
   * **Atomic Operation**: The operation is atomic - all todos succeed or all fail (rollback on any error).
   * This ensures data consistency. If any todo in the batch cannot be deleted (e.g., not found),
   * the entire operation fails and no todos are deleted.
   * 
   * @param request - Bulk delete request (flattened)
   * @returns void (204 No Content)
   * @throws Error with message if exceeds max limit (400), any todo not found (404), or server error (500)
   * 
   * @example Basic bulk delete
   * await client.bulkDelete({
   *   ids: ["550e8400-e29b-41d4-a716-446655440000", "660e8400-e29b-41d4-a716-446655440001"]
   * });
   * 
   * @example Batch processing for large sets (>100 todos)
   * const allTodoIds = [...]; // Array of more than 100 IDs
   * const batchSize = 100;
   * for (let i = 0; i < allTodoIds.length; i += batchSize) {
   *   const batch = allTodoIds.slice(i, i + batchSize);
   *   await client.bulkDelete({ ids: batch });
   * }
   * 
   * @tags: ["mutating", "batch", "delete"]
   */
  bulkDelete(request: BulkDeleteRequest): Promise<void>;
}

// ============================================================================
// User Journey Examples
// ============================================================================

/**
 * Realistic User Journey Examples
 * 
 * These examples demonstrate common use cases and patterns for using the IApiClient interface.
 * Each journey shows the step-by-step approach using pseudo-TypeScript code with descriptive
 * comments. Date calculations and transformations are omitted - calculate dates client-side
 * and pass absolute dates (YYYY-MM-DD format) to the API.
 * 
 * Note: Filtering is to be performed server-side as much as possible. Combine multiple filters in a single listTodos
 * call to avoid or reduce client-side post-processing.
 */

/**
 * Journey 1: Mark all high-priority incomplete todos from this month as complete
 * 
 * Scenario: User wants to mark all high-priority incomplete todos that were due this month as complete.
 * 
 * Approach:
 * 1. Calculate month start and end dates - done client-side
 * 2. Find high-priority incomplete todos in date range using combined filters
 * 3. Extract IDs and bulk update in batches
 */
/*
// Calculate month start and end dates client-side

todos = listTodos({
  status: "notEquals:complete",
  priority: "equals:high",
  dueDateAfter: monthStart,
  dueDateBefore: monthEnd
});

// Only proceed if non-empty todos

// Extract IDs from todos

// Process in batches of 100 todos (because of bulkUpdateStatus limit)

bulkUpdateStatus({ids: batchTodoIdsOfHundredEach, status: "complete"})
*/

/**
 * Journey 2: Delete all completed todos from last quarter
 * 
 * Scenario: User wants to clean up by deleting all completed todos that were due in the previous quarter.
 * 
 * Approach:
 * 1. Calculate quarter start and end dates - done client-side
 * 2. Find completed todos in that date range using combined filters
 * 3. Extract IDs and bulk delete in batches
 */
/*
// Calculate quarter start and end dates client-side

completedTodos = listTodos({
  status: "equals:complete",
  dueDateAfter: quarterStart,
  dueDateBefore: quarterEnd
});

// Only proceed if non-empty todos

// Extract IDs from todos

// Process in batches of 100 todos (because of bulkDelete limit)

bulkDelete({ids: batchTodoIdsOfHundredEach})
*/

/**
 * Journey 3: Upgrade priority of all low-priority incomplete todos to medium
 * 
 * Scenario: User wants to upgrade all low-priority incomplete todos to medium priority.
 * 
 * Approach:
 * 1. Find all low-priority incomplete todos using combined filters
 * 2. Update each todo's priority individually
 */
/*
todosToUpgrade = listTodos({
  status: "notEquals:complete",
  priority: "equals:low"
});

// For each todo in the result, update its priority to medium

updateTodo({id: todoId, priority: "medium"})
*/

/**
 * Journey 4: Create a task reminder next week
 * 
 * Scenario: User wants to create a todo for team sync that happens next Monday.
 * 
 * Approach:
 * 1. Calculate next Monday date - done client-side
 * 2. Create todo with title, due date, and priority
 */
/*
// Calculate next Monday date client-side

createTodo({title: "team sync", dueDate: nextMonday, priority: "medium"})
*/

/**
 * Journey 5: Create product launch checklist todos
 * 
 * Scenario: User is preparing for a product launch and needs to create multiple checklist items
 * with different priorities and due dates.
 * 
 * Approach:
 * 1. Create multiple todos sequentially or in parallel
 * 2. Each todo represents a different launch task with specific due date and priority
 */
/*
createTodo({title: "finalize product documentation", dueDate: "2025-12-01", priority: "high"})

createTodo({title: "run final QA testing", dueDate: "2025-12-05", priority: "urgent"})

createTodo({title: "prepare marketing materials", dueDate: "2025-12-03", priority: "high"})

createTodo({title: "schedule launch announcement", dueDate: "2025-12-10", priority: "medium"})
*/

/**
 * Journey 6: Find and review high-priority incomplete todos
 * 
 * Scenario: User wants to see all high or urgent priority todos that are not complete.
 * 
 * Approach:
 * 1. Use listTodos with status and priority filters
 * 2. May need multiple queries for different priority levels
 */
/*
highPriorityTodos = listTodos({status: "notEquals:complete", priority: "equals:high"})

urgentTodos = listTodos({status: "notEquals:complete", priority: "equals:urgent"})

// Combine results if needed
*/

/**
 * Journey 7: Delete completed todos from last month
 * 
 * Scenario: User wants to delete all completed todos that were due last month.
 * 
 * Approach:
 * 1. Calculate last month's date range - done client-side
 * 2. Find completed todos in that date range
 * 3. Bulk delete in batches
 */
/*
// Calculate last month's start and end dates client-side

completedTodos = listTodos({
  status: "equals:complete",
  dueDateAfter: lastMonthStart,
  dueDateBefore: lastMonthEnd
});

// Only proceed if non-empty todos

// Extract IDs from todos

// Process in batches of 100 todos

bulkDelete({ids: batchTodoIdsOfHundredEach})
*/

/**
 * Journey 8: Update a specific todo's status and priority
 * 
 * Scenario: User wants to mark a specific todo as complete and change its priority.
 * 
 * Approach:
 * 1. Get todo by ID to verify it exists (optional)
 * 2. Update todo with new status and priority
 */
/*
// Optional: Verify todo exists first

getTodoById({id: todoId})

// Update todo with new status and priority

updateTodo({id: todoId, status: "complete", priority: "low"})
*/

/**
 * Journey 9: Find todos due today or overdue
 * 
 * Scenario: User wants to see all todos that need immediate attention (due today or overdue).
 * 
 * Approach:
 * 1. Calculate today's date - done client-side
 * 2. Find todos with status "due" OR todos due today (may need two queries)
 */
/*
// Calculate today's date client-side

// Find overdue todos

overdueTodos = listTodos({status: "equals:due"})

// Find todos due today (status initial but dueDate is today)

todosDueToday = listTodos({status: "equals:initial", dueDateAfter: today, dueDateBefore: today})

// Combine results
*/

/**
 * Journey 10: Bulk mark project-related todos as complete
 * 
 * Scenario: User finished a project and wants to mark all todos related to that project
 * (identified by project name in title or description) as complete.
 * 
 * Approach:
 * 1. Find todos with project name in title OR description
 * 2. May need multiple queries and combine results
 * 3. Bulk update status in batches
 */
/*
// Find todos with project name in title

todosInTitle = listTodos({title: "contains:Q4 Planning"})

// Find todos with project name in description

todosInDescription = listTodos({description: "contains:Q4 Planning"})

// Combine and deduplicate by ID

// Only proceed if non-empty todos

// Extract IDs from unique todos

// Process in batches of 100 todos

bulkUpdateStatus({ids: batchTodoIdsOfHundredEach, status: "complete"})
*/

